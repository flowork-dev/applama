<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Video Cloak | Ultimate Defense</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet">

    <style>
        /* THEME CONFIG */
        :root {
            --bg-core: #171925;
            --surface-1: #1f2233;
            --surface-2: #12141d;
            --border-color: rgba(84, 215, 246, 0.2);
            --primary: #54d7f6;
            --secondary: #706bf3;
            --accent: #0aff60;
            --danger: #ff2a6d;
            --txt-main: #e0f0ff;
            --txt-muted: #94a3b8;
        }

        body {
            background-color: var(--bg-core);
            color: var(--txt-main);
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden; /* BODY GAK BOLEH SCROLL */
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        .orbitron { font-family: 'Orbitron', sans-serif; }

        /* Custom Scrollbar (Hanya muncul di area settings) */
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: var(--surface-1); border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: var(--primary); }

        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: var(--primary); cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 10px var(--primary);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: var(--surface-2); border-radius: 2px;
        }

        .glass-panel {
            background-color: var(--surface-1);
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="flex flex-col h-screen w-full">

    <nav class="h-14 shrink-0 z-50 flex items-center justify-between px-4 border-b bg-[#171925]/95 backdrop-blur"
         style="border-color: var(--border-color);">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded flex items-center justify-center border"
                 style="background: rgba(84, 215, 246, 0.1); border-color: var(--primary); color: var(--primary);">
                <i class="mdi mdi-shield-lock text-lg"></i>
            </div>
            <div>
                <h1 class="orbitron text-base font-bold leading-none tracking-widest text-white">
                    VIDEO <span style="color: var(--primary);">CLOAK</span>
                </h1>
                <div class="text-[8px] tracking-[0.3em] font-bold opacity-60">ULTIMATE</div>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <div class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse"></div>
            <span class="text-[9px] font-bold text-gray-500 hidden md:inline">SYSTEM ACTIVE</span>
        </div>
    </nav>

    <div id="cloak-app-mount" class="flex-1 w-full relative flex flex-col lg:flex-row overflow-hidden">

        <div class="w-full lg:w-[60%] h-[40dvh] lg:h-full shrink-0 relative bg-black border-b lg:border-b-0 lg:border-r z-20 shadow-2xl"
             style="border-color: var(--border-color);">

            <div v-if="!videoSrc" class="absolute inset-0 z-20 flex flex-col items-center justify-center cursor-pointer hover:bg-white/5 transition-colors active:scale-95" @click="triggerUpload">
                <div class="w-16 h-16 rounded-full flex items-center justify-center mb-3 border shadow-[0_0_20px_rgba(84,215,246,0.15)] animate-pulse"
                     style="background-color: var(--surface-1); border-color: var(--primary);">
                    <i class="mdi mdi-upload text-3xl" style="color: var(--primary);"></i>
                </div>
                <h3 class="orbitron text-sm font-bold tracking-widest text-white">TAP TO UPLOAD</h3>
                <p class="text-[10px] mono mt-1 opacity-60">MP4 / WEBM / MOV</p>
                <input type="file" ref="fileInput" class="hidden" accept="video/*" @change="handleFile">
            </div>

            <div class="absolute inset-0 flex items-center justify-center bg-black">
                <video ref="videoRef" class="absolute top-0 left-0 w-px h-px opacity-0 pointer-events-none" crossorigin="anonymous" playsinline></video>
                <canvas ref="canvasRef" class="max-w-full max-h-full object-contain"></canvas>
            </div>

            <div v-if="videoSrc && !isProcessing" class="absolute top-2 right-2 z-20">
                 <button @click="triggerUpload" class="p-2 bg-black/60 rounded-lg text-white hover:text-red-400 backdrop-blur border border-white/10 shadow-lg">
                    <i class="mdi mdi-refresh text-lg"></i>
                 </button>
            </div>

            <div v-if="isProcessing" class="absolute inset-0 z-30 bg-black/90 flex flex-col items-center justify-center backdrop-blur-sm">
                <div class="relative w-16 h-16 mb-4">
                    <div class="absolute inset-0 border-4 border-gray-800 rounded-full"></div>
                    <div class="absolute inset-0 border-4 border-t-cyan-500 rounded-full animate-spin"></div>
                    <div class="absolute inset-0 flex items-center justify-center">
                        <span class="orbitron font-bold text-white text-sm">{{ progressPercent }}%</span>
                    </div>
                </div>
                <div class="text-cyan-400 font-bold orbitron text-xs animate-pulse tracking-widest">RENDERING...</div>
                <div class="text-gray-500 text-[10px] mono mt-2">{{ statusText }}</div>
            </div>
        </div>

        <div class="flex-1 w-full lg:w-[40%] h-full overflow-y-auto custom-scroll relative bg-core">

            <div class="p-4 pb-32 space-y-4">

                <div class="glass-panel p-4 rounded-xl">
                    <h2 class="text-white font-bold orbitron flex items-center gap-2 text-xs border-b border-gray-700 pb-2 mb-2">
                        <i class="mdi mdi-tune text-cyan-400"></i> CONFIGURATION
                    </h2>
                    <div class="text-[10px] text-gray-400 mono flex justify-between items-center">
                        <span>MODE: SWAP-SPLIT</span>
                        <span v-if="videoSrc" class="text-green-400 font-bold bg-green-900/20 px-2 rounded border border-green-500/20">READY</span>
                        <span v-else class="text-gray-600 bg-gray-800 px-2 rounded">IDLE</span>
                    </div>
                </div>

                <div class="glass-panel p-4 rounded-xl space-y-4">
                    <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-1">
                        <span class="text-xs font-bold text-white orbitron">AUDIO JAMMER</span>
                        <button @click="toggleAudioPreview" :disabled="!videoSrc || isProcessing"
                                :class="isPreviewing ? 'text-red-400 border-red-500/50' : 'text-cyan-400 border-cyan-500/30'"
                                class="text-[9px] font-bold px-2 py-1 border rounded hover:bg-white/5 disabled:opacity-30 flex items-center gap-1 transition-all">
                            <i :class="isPreviewing ? 'mdi mdi-stop' : 'mdi mdi-play'"></i> {{ isPreviewing ? 'STOP' : 'TEST' }}
                        </button>
                    </div>
                    <div>
                        <label class="block text-[9px] font-mono text-green-400 mb-1 flex justify-between">
                            <span>ORIGINAL</span> <span>{{ volOriginal }}%</span>
                        </label>
                        <input type="range" v-model="volOriginal" @input="updateAudioParams" min="0" max="150" class="w-full h-1.5 rounded-lg">
                    </div>
                    <div>
                        <label class="block text-[9px] font-mono text-cyan-400 mb-1 flex justify-between">
                            <span>NOISE FILL</span> <span>{{ volJammer }}%</span>
                        </label>
                        <input type="range" v-model="volJammer" @input="updateAudioParams" min="0" max="150" class="w-full h-1.5 rounded-lg">
                    </div>
                </div>

                <div class="glass-panel p-4 rounded-xl space-y-3">
                    <div class="text-xs font-bold text-white orbitron border-b border-gray-700 pb-2">VISUAL EVASION</div>
                    <div class="flex items-center justify-between">
                        <span class="text-[10px] text-gray-400">Micro-Zoom & Pan</span>
                        <span class="text-[9px] text-cyan-400 font-bold bg-cyan-900/20 px-1.5 rounded">ACTIVE</span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span class="text-[10px] text-gray-400">Color Matrix Shift</span>
                        <span class="text-[9px] text-cyan-400 font-bold bg-cyan-900/20 px-1.5 rounded">ACTIVE</span>
                    </div>
                    <div class="flex items-center justify-between pt-1">
                        <span class="text-[10px] text-gray-400">Mirror Mode</span>
                        <button @click="isMirrored = !isMirrored" :class="isMirrored ? 'bg-cyan-500 text-black' : 'bg-gray-700 text-gray-400'" class="px-3 py-0.5 rounded text-[9px] font-bold transition-colors">
                            {{ isMirrored ? 'ON' : 'OFF' }}
                        </button>
                    </div>
                </div>

                <div class="glass-panel p-4 rounded-xl shadow-lg border-t-2 border-cyan-500/50">
                    <button @click="startProcess" :disabled="!videoSrc || isProcessing"
                        class="w-full py-4 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 disabled:from-gray-700 disabled:to-gray-800 disabled:text-gray-500 text-white font-black rounded-lg orbitron tracking-widest transition-all shadow-lg transform active:scale-95 disabled:scale-100 flex items-center justify-center gap-2 text-xs">
                        <span v-if="!isProcessing"><i class="mdi mdi-shield-check text-base"></i> EXECUTE CLOAK</span>
                        <span v-else><i class="mdi mdi-loading mdi-spin"></i> PROCESSING...</span>
                    </button>

                    <div v-if="downloadUrl" class="mt-3 animate-pulse">
                        <a :href="downloadUrl" :download="outputName" class="block w-full py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg text-[10px] tracking-widest text-center transition shadow-lg border border-green-400/50">
                            <i class="mdi mdi-download mr-1"></i> DOWNLOAD RESULT
                        </a>
                    </div>
                </div>

                <div id="global-footer" class="mt-8 pt-4 border-t border-gray-800/50"></div>

            </div>
        </div>

    </div>

    <script>
        // 1. FOOTER LOADER (Penting: Path harus benar)
        // Paste ini di bagian <script> paling bawah index.html

async function loadFooter() {
    try {
        const response = await fetch('/assets/lander/footer.html');
        if (!response.ok) throw new Error('Footer not found');

        let html = await response.text();

        // --- AUTO YEAR UPDATE LOGIC ---
        // Ini kuncinya: Ganti tulisan "{YEAR}" dengan tahun realtime
        const realYear = new Date().getFullYear();
        html = html.replace('{YEAR}', realYear);

        document.getElementById('global-footer').innerHTML = html;

        // Re-init icons (Penting biar icon muncul)
        if(window.lucide) window.lucide.createIcons();

    } catch (e) {
        console.warn("Footer load failed:", e);
        // Fallback jika file gagal load
        const year = new Date().getFullYear();
        document.getElementById('global-footer').innerHTML =
            `<div class="p-8 text-center text-gray-600 font-mono text-xs">Â© ${year} FLOWORK [OFFLINE]</div>`;
    }
}

loadFooter();

        // 2. VUE ENGINE
        const { createApp, ref, nextTick, onMounted } = Vue;

        createApp({
            setup() {
                // STATE
                const videoSrc = ref(null);
                const isProcessing = ref(false);
                const isPreviewing = ref(false);
                const progressPercent = ref(0);
                const statusText = ref('SYSTEM READY');
                const downloadUrl = ref(null);
                const outputName = ref('');

                // SETTINGS
                const volOriginal = ref(100);
                const volJammer = ref(80);
                const isMirrored = ref(false);

                // REFS
                const fileInput = ref(null);
                const videoRef = ref(null);
                const canvasRef = ref(null);

                // ENGINE
                let audioCtx = null;
                let originalBuffer = null;
                let previewSource = null;
                let previewDebounce = null;
                let animationId = null;
                let mediaRecorder = null;

                const triggerUpload = () => {
                    if(fileInput.value) fileInput.value.click();
                };

                const handleFile = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    if (videoSrc.value) URL.revokeObjectURL(videoSrc.value);
                    if (downloadUrl.value) URL.revokeObjectURL(downloadUrl.value);
                    stopAudioPreview();
                    downloadUrl.value = null;

                    videoSrc.value = URL.createObjectURL(file);
                    outputName.value = `CLOAKED_${Math.floor(Math.random()*10000)}.mp4`;

                    nextTick(async () => {
                        const vid = videoRef.value;
                        const cvs = canvasRef.value;
                        vid.src = videoSrc.value;

                        statusText.value = "READING AUDIO...";
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                            statusText.value = "AUDIO LOADED";
                        } catch(err) {
                            console.error(err);
                            statusText.value = "AUDIO ERROR (MUTED)";
                        }

                        vid.onloadedmetadata = () => {
                            cvs.width = vid.videoWidth;
                            cvs.height = vid.videoHeight;
                            const ctx = cvs.getContext('2d');
                            ctx.drawImage(vid, 0, 0);
                        };
                    });
                };

                const processAudioTrack = async (duration, isPreview = false) => {
                    if (!originalBuffer) return null;
                    const sampleRate = originalBuffer.sampleRate;
                    const renderDuration = isPreview ? Math.min(5, duration) : duration;
                    const frameCount = Math.floor(renderDuration * sampleRate);
                    const offlineCtx = new OfflineAudioContext(originalBuffer.numberOfChannels, frameCount, sampleRate);

                    const source = offlineCtx.createBufferSource();
                    const tempBuf = offlineCtx.createBuffer(originalBuffer.numberOfChannels, frameCount, sampleRate);
                    for(let c=0; c<originalBuffer.numberOfChannels; c++) tempBuf.copyToChannel(originalBuffer.getChannelData(c).slice(0, frameCount), c);
                    source.buffer = tempBuf;

                    const sourceGain = offlineCtx.createGain();
                    sourceGain.gain.value = volOriginal.value / 100;
                    source.connect(sourceGain);
                    sourceGain.connect(offlineCtx.destination);

                    const jammerBuffer = offlineCtx.createBuffer(originalBuffer.numberOfChannels, frameCount, sampleRate);
                    const splitPoint = Math.floor(frameCount / 2);

                    for (let ch = 0; ch < originalBuffer.numberOfChannels; ch++) {
                        const inputData = tempBuf.getChannelData(ch);
                        const outputData = jammerBuffer.getChannelData(ch);
                        let envelope = 0;
                        for(let i = 0; i < frameCount; i++) {
                            let srcIdx = (i < (frameCount - splitPoint)) ? splitPoint + i : i - (frameCount - splitPoint);
                            let rawSample = (srcIdx < inputData.length) ? inputData[srcIdx] : 0;
                            const absInput = Math.abs(inputData[i]);
                            envelope = envelope * 0.999 + absInput * 0.001;
                            let silenceBoost = 1.0;
                            if(envelope < 0.05) silenceBoost = 1.0 + ((0.05 - envelope) * 20.0);
                            outputData[i] = rawSample * silenceBoost;
                        }
                    }
                    const jammerSource = offlineCtx.createBufferSource();
                    jammerSource.buffer = jammerBuffer;
                    const jammerGain = offlineCtx.createGain();
                    jammerGain.gain.value = volJammer.value / 100;
                    jammerSource.connect(jammerGain);
                    jammerGain.connect(offlineCtx.destination);

                    source.start();
                    jammerSource.start();
                    return await offlineCtx.startRendering();
                };

                const toggleAudioPreview = async () => {
                    if (isPreviewing.value) { stopAudioPreview(); }
                    else {
                        if (!originalBuffer) return;
                        isPreviewing.value = true;
                        const renderedBuffer = await processAudioTrack(videoRef.value.duration, true);
                        const loopCtx = new (window.AudioContext || window.webkitAudioContext)();
                        previewSource = loopCtx.createBufferSource();
                        previewSource.buffer = renderedBuffer;
                        previewSource.loop = true;
                        previewSource.connect(loopCtx.destination);
                        previewSource.start();
                    }
                };

                const stopAudioPreview = () => {
                    if (previewSource) { try { previewSource.stop(); } catch(e){} previewSource = null; }
                    isPreviewing.value = false;
                };

                const updateAudioParams = () => {
                    if(isPreviewing.value) {
                        if(previewDebounce) clearTimeout(previewDebounce);
                        previewDebounce = setTimeout(() => { stopAudioPreview(); toggleAudioPreview(); }, 150);
                    }
                };

                const startProcess = async () => {
                    if (!videoSrc.value) return;
                    isProcessing.value = true;
                    stopAudioPreview();
                    statusText.value = "ENGINE START...";

                    const vid = videoRef.value;
                    const cvs = canvasRef.value;
                    const ctx = cvs.getContext('2d');

                    statusText.value = "PROCESSING AUDIO...";
                    const finalAudioBuffer = await processAudioTrack(vid.duration, false);
                    const destAudioNode = audioCtx.createMediaStreamDestination();
                    const finalAudioSource = audioCtx.createBufferSource();
                    finalAudioSource.buffer = finalAudioBuffer;
                    finalAudioSource.connect(destAudioNode);

                    const canvasStream = cvs.captureStream(30);
                    const combinedStream = new MediaStream([ ...canvasStream.getVideoTracks(), ...destAudioNode.stream.getAudioTracks() ]);

                    let mimeType = 'video/webm; codecs=vp9';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4';

                    mediaRecorder = new MediaRecorder(combinedStream, { mimeType, videoBitsPerSecond: 8000000 });
                    const chunks = [];
                    mediaRecorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: mimeType });
                        downloadUrl.value = URL.createObjectURL(blob);
                        isProcessing.value = false;
                        statusText.value = "COMPLETED";
                        vid.pause(); vid.currentTime = 0;
                        cancelAnimationFrame(animationId);
                    };

                    statusText.value = "RENDERING CLOAK...";
                    vid.currentTime = 0; vid.playbackRate = 1.0; vid.muted = true;
                    await vid.play();
                    finalAudioSource.start();
                    mediaRecorder.start();

                    let speedPhase = 0;
                    const drawFrame = () => {
                        if (vid.paused || vid.ended) {
                            if (mediaRecorder.state === 'recording') mediaRecorder.stop();
                            return;
                        }
                        progressPercent.value = Math.floor((vid.currentTime / vid.duration) * 100);

                        // Visual FX
                        speedPhase += 0.02;
                        vid.playbackRate = 1.0 + (Math.sin(speedPhase) * 0.03);

                        const w = cvs.width;
                        const h = cvs.height;
                        ctx.clearRect(0,0,w,h);

                        const zoomSpeed = 0.05;
                        const scale = 1.0 + (Math.sin(vid.currentTime * zoomSpeed) * 0.02);
                        const panX = Math.cos(vid.currentTime * 0.1) * (w * 0.01);
                        const panY = Math.sin(vid.currentTime * 0.1) * (h * 0.01);

                        const dw = w * scale;
                        const dh = h * scale;
                        const dx = ((w - dw) / 2) + panX;
                        const dy = ((h - dh) / 2) + panY;

                        ctx.save();
                        if(isMirrored.value) { ctx.translate(w, 0); ctx.scale(-1, 1); }
                        ctx.drawImage(vid, dx, dy, dw, dh);
                        ctx.restore();

                        ctx.globalCompositeOperation = 'overlay';
                        ctx.fillStyle = `rgba(${10 + Math.sin(vid.currentTime)*10}, 0, ${10 + Math.cos(vid.currentTime)*10}, 0.05)`;
                        ctx.fillRect(0,0,w,h);
                        ctx.globalCompositeOperation = 'source-over';

                        if (Math.random() > 0.8) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
                            ctx.fillRect(0, Math.random() * h, w, 2);
                        }
                        animationId = requestAnimationFrame(drawFrame);
                    };
                    drawFrame();
                };

                onMounted(() => { if(window.lucide) window.lucide.createIcons(); });

                return {
                    videoSrc, isProcessing, isPreviewing, progressPercent, statusText, downloadUrl, outputName,
                    volOriginal, volJammer, isMirrored, fileInput, videoRef, canvasRef,
                    triggerUpload, handleFile, startProcess, toggleAudioPreview, updateAudioParams
                };
            }
        }).mount('#cloak-app-mount');
    </script>
</body>
</html>